<!DOCTYPE html>
<html>
	<head>
		<title>Blox</title>
		<style>
			body { padding: 0; margin: 0; }
			canvas { width: 100%; }
		</style>
	</head>
	<body>
		<div><canvas id='blox'></canvas></div>
		<div id='framerate'></div>
<script src="sylvester-0-1-3/sylvester.src.js"></script>
<script id='fragment' type='x-shader/x-fragment'>
	#ifdef GL_ES
	precision highp float;
	#endif

	varying vec4 color;
	varying vec3 light;

	void main(void) {
		gl_FragColor = vec4(color.rgb * light, color.a);
	}
</script>
<script id='vertex' type='x-shader/x-vertex'>
	attribute vec3 vertexPos;
	attribute vec4 vertexColor;
	attribute vec3 vertexNormal;

	uniform mat4 projection;
	uniform mat4 modelView;
	uniform mat3 normalMatrix;

	uniform vec3 lightColor;
	uniform vec3 lightDir;
	uniform vec3 ambientColor;

	varying vec4 color;
	varying vec3 light;

	void main(void) {
		gl_Position = projection * modelView * vec4(vertexPos, 1.0);
		color = vertexColor;
		vec3 transformedNormal = normalMatrix * vertexNormal;
		float weighting = max(dot(transformedNormal, lightDir), 0.0);
		light = ambientColor + lightColor * weighting;
	}
</script>
<script>
var gl

function initWebGL(canvas) {
	var gl = null
	var types = ['webgl', 'experimental-webgl', 'webkit-3d', 'moz-webgl']
	for (var i = 0; i < types.length; i++) {
		try {
			gl = canvas.getContext(types[i], { antialias: false })
		} catch (e) {
		}
		if (gl) {
			return gl
		}
	}
}

function setFps(fps) {
	document.getElementById('framerate').innerHTML = fps.toFixed(2)
}

var Frame = (function (cb) {
	var lastFrame, frames = 0;
	return function () {
		var now = Date.now()
		if (!lastFrame) { lastFrame = now }
		frames++
		if (now - lastFrame > 1000) {
			cb(frames/(now - lastFrame)*1000)
			lastFrame = now
			frames = 0
		}
	}
})(setFps)

// Compiles a shader from source in a
// <script type='x-shader/x-{vertex,fragment}'> tag
function getShader(id) {
	var el = document.getElementById(id)
	if (!el) { return }
	var source = ""
	for (var node = el.firstChild; node; node = node.nextSibling) {
		source += node.textContent
	}
	var shader
	if (el.type === 'x-shader/x-fragment') {
		shader = gl.createShader(gl.FRAGMENT_SHADER)
	} else if (el.type === 'x-shader/x-vertex') {
		shader = gl.createShader(gl.VERTEX_SHADER)
	} else {
		return
	}
	gl.shaderSource(shader, source)
	gl.compileShader(shader)
	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		console.log("Error compiling the shader '"+id+"': "+gl.getShaderInfoLog(shader))
		return
	}

	return shader
}

Matrix.prototype.flatten = function () {
    var result = [];
    if (this.elements.length == 0)
        return [];


    for (var j = 0; j < this.elements[0].length; j++)
        for (var i = 0; i < this.elements.length; i++)
            result.push(this.elements[i][j]);
    return result;
}

function ShaderProgram(program) {
	this.program = program
}

ShaderProgram.prototype.use = function () {
	gl.useProgram(this.program)
}
ShaderProgram.prototype.uniform = function (uname, value) {
	this.use()
	var loc = gl.getUniformLocation(this.program, uname)
	if (!loc) {
		throw new Error("No such uniform: " + uname)
	}
	if (value instanceof Matrix) {
		if (value.rows() === 4 && value.cols() === 4) {
			gl.uniformMatrix4fv(loc, false, new Float32Array(value.flatten()))
		} else if (value.rows() === 3 && value.cols() === 3) {
			gl.uniformMatrix3fv(loc, false, new Float32Array(value.flatten()))
		} else {
			console.log("don't know how to set a uniform to",value)
		}
	} else if (value instanceof Array) {
		if (value.length === 3) {
			gl.uniform3fv(loc, value)
		} else if (value.length === 4) {
			gl.uniform4fv(loc, value)
		} else {
			console.log("don't know how to set a uniform to",value)
		}
	} else {
		console.log("don't know how to set a uniform to",value)
	}
}
ShaderProgram.prototype.attrLoc = function (aname) {
	this.use()
	return gl.getAttribLocation(this.program, aname)
}

function createProgram(vertId, fragId) {
	var vert = getShader(vertId)
	var frag = getShader(fragId)

	if (vert === undefined || frag === undefined) { return }

	var program = gl.createProgram()
	gl.attachShader(program, vert)
	gl.attachShader(program, frag)
	gl.linkProgram(program)

	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
		console.log("Couldn't link shaders: "+gl.getProgramInfoLog(program))
		return
	}

	gl.useProgram(program)

	var sprog = new ShaderProgram(program)

	sprog.positionAttr = gl.getAttribLocation(program, "vertexPos");
	gl.enableVertexAttribArray(sprog.positionAttr)
	sprog.colorAttr = gl.getAttribLocation(program, "vertexColor");
	gl.enableVertexAttribArray(sprog.colorAttr)
	sprog.normalAttr = gl.getAttribLocation(program, "vertexNormal");
	gl.enableVertexAttribArray(sprog.normalAttr)

	return sprog
}

function makeFrustum(left, right, bottom, top, znear, zfar) {
	var X = 2*znear/(right-left)
	var Y = 2*znear/(top-bottom)
	var A = (right+left)/(right-left)
	var B = (top+bottom)/(top-bottom)
	var C = -(zfar+znear)/(zfar-znear)
	var D = -2*zfar*znear/(zfar-znear)

	return $M([[X, 0, A, 0],
	           [0, Y, B, 0],
	           [0, 0, C, D],
	           [0, 0, -1, 0]])
}

function makePerspective(fovy, aspect, znear, zfar) {
	var ymax = znear * Math.tan(fovy * Math.PI / 360.0)
	var ymin = -ymax
	var xmin = ymin * aspect
	var xmax = ymax * aspect

	return makeFrustum(xmin, xmax, ymin, ymax, znear, zfar)
}

function main() {
	var canvas = document.getElementById('blox')
	gl = initWebGL(canvas)
	if (!gl) {
		canvas.parentNode.innerHTML = "Couldn't initialize webgl :("
		return
	}

	var program = createProgram("vertex","fragment")
	if (program === undefined) {
		console.log("Exiting.")
		return
	}

	canvas.width = Math.floor(window.innerWidth)
	canvas.height = Math.floor(window.innerHeight * 0.9)
	gl.viewport(0, 0, canvas.width, canvas.height)

	gl.clearColor(0,0,0,1)
	gl.enable(gl.CULL_FACE)
	gl.enable(gl.DEPTH_TEST)

	var LEFT = 0, RIGHT = 1, BOTTOM = 2, TOP = 3, BACK = 4, FRONT = 5
	var normalX = [-1, 1, 0, 0, 0, 0]
	var normalY = [0, 0, -1, 1, 0, 0]
	var normalZ = [0, 0, 0, 0, -1, 1]
	var chunkVertPos = []
	var chunkVertNormal = []
	var chunkVertColor = []
	for (var f = 0; f < 6; f++) {
		for (var y = 0; y < 16; y++) {
			for (var x = 0; x < 16; x++) {
				for (var z = 0; z < 16; z++) {
					var v = f*16*16*16+y*16*16+x*16+z
					chunkVertPos[3*v] = x
					chunkVertPos[3*v+1] = y
					chunkVertPos[3*v+2] = z
					chunkVertColor[4*v] = Math.min(x/16, 1)
					chunkVertColor[4*v+1] = Math.min(y/16, 1)
					chunkVertColor[4*v+2] = Math.min(z/16, 1)
					chunkVertColor[4*v+3] = 1
					chunkVertNormal[3*v] = normalX[f]
					chunkVertNormal[3*v+1] = normalY[f]
					chunkVertNormal[3*v+2] = normalZ[f]
				}
			}
		}
	}

	/*
     y+
     |
     |
		 |
		 o---- x+
    /
   /
  z+ (out of screen)

	*/

	var cubeIdcs = [
		[0,0,0], [0,1,1], [0,1,0], // yz, x=0 LEFT
		[0,0,0], [0,0,1], [0,1,1],
		[1,1,1], [1,0,0], [1,1,0], // yz, x=1 RIGHT
		[1,1,1], [1,0,1], [1,0,0],
		[0,0,0], [1,0,1], [0,0,1], // xz, y=0 BOTTOM
		[0,0,0], [1,0,0], [1,0,1],
		[1,1,1], [0,1,0], [0,1,1], // xz, y=1 TOP
		[1,1,1], [1,1,0], [0,1,0],
		[0,0,0], [1,1,0], [1,0,0], // xy, z=0 BACK
		[0,0,0], [0,1,0], [1,1,0],
		[1,1,1], [0,0,1], [1,0,1], // xy, z=1 FRONT
		[1,1,1], [0,1,1], [0,0,1],
	]

	var chunk = []
	for (var y = 0; y < 16; y++) {
		for (var x = 0; x < 16; x++) {
			for (var z = 0; z < 16; z++) {
				var v = y*16*16+x*16+z
				var dx = (x-4), dy = (y-4), dz = (z-4)
				if (dx*dx+dy*dy+dz*dz <= 16) {
					chunk[v] = 1
				} else {
					chunk[v] = 0
				}
			}
		}
	}

	// all the vertices and their properties
	var chunkBuf = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, chunkBuf)
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(chunkVertPos), gl.STATIC_DRAW)

	var colorBuf = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, colorBuf)
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(chunkVertColor), gl.STATIC_DRAW)

	var normalBuf = gl.createBuffer()
	gl.bindBuffer(gl.ARRAY_BUFFER, normalBuf)
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(chunkVertNormal), gl.STATIC_DRAW)


	// the index buffer
	var indexBuf = gl.createBuffer()
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuf)
	var chunkIdx
	function rebuildChunk() {
		chunkIdx = []
		for (var y = 0; y < 16; y++) {
			for (var x = 0; x < 16; x++) {
				for (var z = 0; z < 16; z++) {
					var v = y*16*16+x*16+z
					if (chunk[v]) {
						for (var f = 0; f < 6; f++) {
							var nx = normalX[f], ny = normalY[f], nz = normalZ[f]
							if (x+nx < 0 || x+nx > 15 ||
									y+ny < 0 || y+ny > 15 ||
									z+nz < 0 || z+nz > 15 ||
									chunk[(y+ny)*16*16+(x+nx)*16+z+nz] == 0) {
								for (var i = 0; i < 6; i++) {
									var dp = cubeIdcs[f*6+i]
									chunkIdx.push(f*16*16*16+(y+dp[1])*16*16+(x+dp[0])*16+(z+dp[2]))
								}
							}
						}
					}
				}
			}
		}
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(chunkIdx), gl.STATIC_DRAW)
	}

	rebuildChunk()

	var proj = makePerspective(60, canvas.width/canvas.height, 0.1, 100)
	var mv = Matrix.I(4)

	function rotY(t) {
		var c = Math.cos(t), s = Math.sin(t)
		return $M([
			[ c, 0, s, 0 ],
			[ 0, 1, 0, 0 ],
			[ -s, 0, c, 0 ],
			[ 0, 0, 0, 1 ],
		])
	}

	var lastFrame = null
	function drawScene() {
		if (lastFrame == null) {
			lastFrame = Date.now()
		}
		var now = Date.now()
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

		mv = Matrix.I(4)
		mv.elements[1][3] = -6
		mv.elements[2][3] = -20
		mv = mv.x(rotY((now - lastFrame) / 1000))

		program.uniform("projection", proj)
		program.uniform("modelView", mv)
		program.uniform("normalMatrix", mv.minor(1,1,3,3).inverse().transpose())
		var o = 1/Math.sqrt(3)
		program.uniform("lightDir", [o,o,o])
		program.uniform("lightColor", [1,1,1])
		program.uniform("ambientColor", [0.3,0.3,0.2])

		gl.bindBuffer(gl.ARRAY_BUFFER, chunkBuf)
		gl.vertexAttribPointer(program.positionAttr, 3, gl.FLOAT, false, 0, 0)
		gl.bindBuffer(gl.ARRAY_BUFFER, colorBuf)
		gl.vertexAttribPointer(program.colorAttr, 4, gl.FLOAT, false, 0, 0)
		gl.bindBuffer(gl.ARRAY_BUFFER, normalBuf)
		gl.vertexAttribPointer(program.normalAttr, 3, gl.FLOAT, false, 0, 0)
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuf)
		gl.drawElements(gl.TRIANGLES, chunkIdx.length, gl.UNSIGNED_SHORT, 0)
	}

	var running = true
	var stop = false

	function tick() {
		if (stop) { running = false; return }
		drawScene()
		Frame()
		window.requestAnimFrame(tick, canvas)
	}

	window.onblur = function () { stop = true }
	window.onfocus = function () {
		stop = false
		if (!running) { tick() }
	}

	canvas.onmousedown = function (e) {
		// translate x/y coords into normalised [-1,1] screen coords
		var ww = canvas.width
		var wh = canvas.height
		var window_x = e.clientX - ww/2
		var window_y = (wh - e.clientY) - wh/2
		var norm_x = 2 * window_x / ww
		var norm_y = 2 * window_y / wh

		// screen coordinate s, world coordinate w, ' = inverse
		// s = P M w
		// so w = M' P' P M w = M' P' s = (P M)' s
		var unview = proj.x(mv).inverse()
		var near_point = unview.x($V([norm_x, norm_y, 0, 1]))
		near_point = near_point.x(1/near_point.elements[3])

		var cam_pos = mv.inverse().col(4)
		var ray_dir = near_point.subtract(cam_pos).toUnitVector()
		// cast ray from cam_pos in direction of ray_dir.
		var origin = {
			x: cam_pos.elements[0],
			y: cam_pos.elements[1],
			z: cam_pos.elements[2],
		}
		var ray = {
			x: ray_dir.elements[0],
			y: ray_dir.elements[1],
			z: ray_dir.elements[2],
		}

		var cx = Math.floor(origin.x)
		var cy = Math.floor(origin.y)
		var cz = Math.floor(origin.z)

		var stepX = ray.x > 0 ? 1 : -1
		var stepY = ray.y > 0 ? 1 : -1
		var stepZ = ray.z > 0 ? 1 : -1
		var nextX = stepX > 0 ? cx+1 : cx
		var nextY = stepY > 0 ? cy+1 : cy
		var nextZ = stepZ > 0 ? cz+1 : cz
		var tMaxX = (nextX-origin.x) / ray.x
		var tMaxY = (nextY-origin.y) / ray.y
		var tMaxZ = (nextZ-origin.z) / ray.z
		var tDeltaX = Math.abs(1/ray.x)
		var tDeltaY = Math.abs(1/ray.y)
		var tDeltaZ = Math.abs(1/ray.z)

		for (var i = 0; i < 1000; i++) {
			if (cx >= 0 && cy >= 0 && cz >= 0 && cx < 16 && cy < 16 && cz < 16) {
				if (chunk[cy*16*16+cx*16+cz]) { break }
			}
			if (tMaxX < tMaxY) {
				if (tMaxX < tMaxZ) {
					cx += stepX
					tMaxX += tDeltaX
				} else {
					cz += stepZ
					tMaxZ += tDeltaZ
				}
			} else {
				if (tMaxY < tMaxZ) {
					cy += stepY
					tMaxY += tDeltaY
				} else {
					cz += stepZ
					tMaxZ += tDeltaZ
				}
			}
		}
		if (i < 1000) {
			console.log(cx, cy, cz)
			chunk[cy*16*16+cx*16+cz] = 0
			rebuildChunk()
		}
	}
	document.onmousemove = function (e) {
	}
	document.onmouseup = function (e) {
	}
	tick()
}

// ugh, browsers
window.requestAnimFrame = (function () {
	return window.requestAnimationFrame ||
	       window.webkitRequestAnimationFrame ||
	       window.mozRequestAnimationFrame ||
	       window.oRequestAnimationFrame ||
	       window.msRequestAnimationFrame ||
	       function(callback, element) {
	         window.setTimeout(callback, 1000/60)
	       }
})()

main()
</script>			
	</body>
</html>
